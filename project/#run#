#!/usr/bin/env scala

val separator = java.io.File.separator match {
case "\\" => "\\\\"
case sep => sep
}

val pathSeparator = System.getProperty("path.separator") match {
case null => println("""WARNING: System.getProperty("path.separator") returned null. Using :""")
case sep => sep
}

val help = """
|run - a simple scala driver for the Scalding workshop.
|usage:
| (*nix): run [scalding_options] script.scala [script_options]
| (Windows): scala run [scalding_options] script.scala [script_options]
|where the "scalding_options" are any options supported by scalding itself
|and the "script_options" will be discussed for each exercise.
|""".stripMargin
// Increase (or decrease) this heap size size value if necessary.

val heapSize = "-Xmx1g"

val assembly = s"target${separator}scala-2.10${separator}activatorscalding-assembly-0.9.1-deps.jar"
val libs = s"target${separator}scala-2.10${separator}classes"
def extractPathNameScript(str: String): (String,String,String) = {
val fullPathScriptREstr = s"""(.*${separator})([^${separator}]+).scala$$"""
val fullPathScriptRE = fullPathScriptREstr.r
val scriptREstr = s"""([^${separator}]+)(.scala)?$$"""
val scriptRE = scriptREstr.r
val (path, name, script) = str match {
case fullPathScriptRE(path, name) =>
(path, name, s"${path}${name}.scala")
case scriptRE(name, _) =>
(s"scripts${separator}", name, s"scripts${separator}${name}.scala")
case _ =>
println(s"Could not parse input script name: $str")
sys.exit(1)
}
(path, name, script)
}
case class Options (
path: String = "",
name: String = "",
script: String = "",
scaldingOptions: Vector[String] = Vector.empty,
scriptOptions: Vector[String] = Vector.empty)
def processScriptArgs(
argz: List[String],
opts: Options): Options = (argz foldLeft opts) {
(opts, arg) => opts copy (scriptOptions = opts.scriptOptions :+ arg)
}
val scriptNameRE = """.*\.sc(?:ala)?$""".r
def processScaldingArgs(
argz: List[String],
opts: Options): Options = argz match {
case Nil => opts
case head :: tail => head match {
case "-h" | "--help" | "--h" =>
println(help)
sys.exit(0)
case script @ scriptNameRE() =>
val (path, name, script) = extractPathNameScript(head)
processScriptArgs(tail, opts copy (path = path, name = name, script = script))
case _ => processScaldingArgs(tail, opts copy (scaldingOptions = opts.scaldingOptions :+ head))
}
}
val options = processScaldingArgs(args.toList, Options())
if (options.script == "") {
println("Must specify a Scalding script!")
println(help)
sys.exit(1)
}
val script = options.script
val scaldingOpts = options.scaldingOptions.mkString(" ")
val scriptOpts = options.scriptOptions.mkString(" ")
import scala.language.postfixOps
import scala.sys.process._
import com.twitter.scalding._
def mkdir(path: String): Unit = {
val dir = new java.io.File(path)
if (dir.exists == false) {
if (dir.mkdir == false) {
println(s"Could not create a required directory: $dir")
sys.exit(1)
}
}
}
mkdir("classes")
def command(step: String, cmdString: String)(cmd: => Int):Int = {
println(s"-- $step: $script")
val status = cmd
if (status != 0) {
println(s"$step Failed for script $script ($cmdString)")
sys.exit(1)
}
status
}
val repl = s"scala -deprecation -cp $assembly"

